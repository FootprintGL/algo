class Solution {
public:
    int sumNums(int n) {
        int sum = 0;
        int A = n, B = n + 1;

        /* 
         * 俄罗斯农夫算法 - 利用逻辑与&&的阻断性质代替条件判断
         * m 为偶数时: m * n = (m / 2) * 2n
         * m 为奇数时: m * m = ((m - 1) / 2) * 2n + n
         * 如果对m进行二进制展开，如果第i位为1，那么这一位对最后结果的贡献为n << i
         * 所有m中bit位为1的结果加起来就是m * n的结果
         * 1 + 2 + 3 + ... + n = n * (n + 1) / 2
         */
        /* 
        for (int i = 0; i < 32; i++) {
            ((B >> i) & 1) && (sum += A << i);
        }
        */

        /* 手动代替循环 - 10000 < 2 ^ 14 */
        /* 第一位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第二位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第三位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第四位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第五位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第六位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第七位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第八位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第九位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第十位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第十一位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第十一位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第十二位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第十三位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        /* 第十四位 */
        (B & 1) && (sum += A);
        B >>= 1;
        A <<= 1;

        return sum >> 1;
    }
};
