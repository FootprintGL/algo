
class Solution {
public:
    /* 统计字符串s中0和1的数量 */
    vector<int> counter(string s) {
        vector<int> cnt (2, 0);
        for (int i = 0; i < s.length(); i++) {
            cnt[s[i] - '0']++;
        }
        return cnt;
    }

    int findMaxForm(vector<string>& strs, int m, int n) {
        /*
         * 动态规划 - 0/1背包问题
         * dp[i][j][k] - j个0，k个1在[0, i]中可以拼出字符串最大数量
         * dp[i][j][k] = max{dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones]}, 两种可能性，选择str[i]和不选str[i]
         * i,j,k前面读多加一圈，注意边界情况，j,k从0开始循环，表示0个1/0，多个0/1的情况
         * dp[i]之和dp[i - 1]关联，可以压缩为2维，需要从后向前更新，避免dp[i - 1]被新值覆盖
         * dp[i][j] = max(dp)
         */
        int len = strs.size();
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0));
        int i, j;

        for (auto str : strs) {
            vector<int> cnt = counter(str);
            for (i = m; i >= cnt[0]; i--) {
                for (j = n; j >= cnt[1]; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - cnt[0]][j - cnt[1]] + 1);
                }
            }
        }

        return dp[m][n];
    }
};


class Solution {
public:
    /* 统计字符串s中0和1的数量 */
    vector<int> counter(string &s) {
        vector<int> cnt (2, 0);
        for (int i = 0; i < s.length(); i++) {
            cnt[s[i] - '0']++;
        }
        return cnt;
    }

    int findMaxForm(vector<string>& strs, int m, int n) {
        /*
         * 动态规划 - 0/1背包问题
         * dp[i][j][k] - j个0，k个1在[0, i]中可以拼出字符串最大数量
         * dp[i][j][k] = max{dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones]}, 两种可能性，选择str[i]和不选str[i]
         * i,j,k前面读多加一圈，注意边界情况，j,k从0开始循环，表示0个1/0，多个0/1的情况
         * dp[i]之和dp[i - 1]关联，可以压缩为2维，需要从后向前更新，避免dp[i - 1]被新值覆盖
         * dp[i][j] = max(dp)
         */
        int len = strs.size();
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0));
        int i, j;

        for (auto str : strs) {
            vector<int> cnt = counter(str);
            for (i = m; i >= cnt[0]; i--) {
                for (j = n; j >= cnt[1]; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - cnt[0]][j - cnt[1]] + 1);
                }
            }
        }

        return dp[m][n];
    }
};


/* 三维动态规划超时了 - counter string &传引用可以通过 */
/*
 * ["11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01"]
50
50
 */
class Solution {
public:
    /* 统计字符串s中0和1的数量 */
    vector<int> counter(string s) {
        vector<int> cnt (2, 0);
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '0')
                cnt[0]++;
            else
                cnt[1]++;
        }
        return cnt;
    }
/*
    vector<int> counter(string s) {
        vector<int> cnt (2, 0);
        for (int i = 0; i < s.length(); i++) {
            cnt[s[i] - '0']++;
        }
        return cnt;
    }
*/

    int findMaxForm(vector<string>& strs, int m, int n) {
        /*
         * 动态规划 - 0/1背包问题
         * dp[i][j][k] - j个0，k个1在[0, i]中可以拼出字符串最大数量
         * dp[i][j][k] = max{dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones]}, 两种可能性，选择str[i]和不选str[i]
         * i,j,k前面读多加一圈，注意边界情况，j,k从0开始循环，表示0个1/0，多个0/1的情况
         */
        int len = strs.size();
        vector<vector<vector<int>>> dp (len + 1, vector<vector<int>> (m + 1, vector<int> (n + 1, 0)));
        int i, j, k;

        for (i = 1; i <= len; i++) {
            for (j = 0; j <= m; j++) {
                for (k = 0; k <= n; k++) {
                    dp[i][j][k] = dp[i - 1][j][k];
                    vector<int> cnt = counter(strs[i - 1]);
                    if (j >= cnt[0] && k >= cnt[1])
                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - cnt[0]][k - cnt[1]] + 1);
                }
            }
        }

        return dp[len][m][n];
    }
};
